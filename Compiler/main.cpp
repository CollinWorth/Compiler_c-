#include <stdio.h>
#include <string.h>
#include "globals.h"
#include "tree.h"
#include "c-.tab.hpp" // Generated by Bison
#include "semantic.h"

// External declarations for variables and functions defined elsewhere
extern FILE *yyin;
extern int yyparse();
extern int yydebug;

// Global variables
TreeNode *syntaxTree = NULL;      // Defined here
int numErrors = 0;                // Defined here
int numWarnings = 0;              // Defined here
SemanticMessage warnings[MAX_WARNINGS];
SymbolTable *symbolTable = NULL;  // Defined here
bool traceParser = false;         // Defined here
bool traceSymbolTable = false;    // Defined here
bool printAST = false;            // Defined here
bool printWithTypeInfo = false;   // Defined here
bool printSource = false;         // Defined here

int yyerror(const char *s) {
    fprintf(stderr, "Parse error: %s\n", s);
    return 0;
}

void printUsage(const char *programName) {
    fprintf(stdout, "usage: %s [options] [sourcefile]\n", programName);
    fprintf(stdout, "options:\n");
    fprintf(stdout, "  -d  - turn on parser debugging\n");
    fprintf(stdout, "  -D  - turn on symbol table debugging\n");
    fprintf(stdout, "  -h  - print this usage message\n");
    fprintf(stdout, "  -p  - print the abstract syntax tree\n");
    fprintf(stdout, "  -P  - print the abstract syntax tree plus type information\n");
    fprintf(stdout, "  -s  - print the source code from the file\n");
}

int main(int argc, char **argv) {
    numErrors = 0;
    numWarnings = 0;
    
    FILE *sourceFile = stdin;
    char *inputFilename = NULL;
    bool helpRequested = false;

    // Parse command-line arguments
    for (int i = 1; i < argc; ++i) {
        if (strcmp(argv[i], "-d") == 0) {
            traceParser = true;
        } else if (strcmp(argv[i], "-D") == 0) {
            traceSymbolTable = true;
        } else if (strcmp(argv[i], "-p") == 0) {
            printAST = true;
        } else if (strcmp(argv[i], "-P") == 0) {
            printAST = true; // -P implies -p
            printWithTypeInfo = true;
        } else if (strcmp(argv[i], "-h") == 0) {
            helpRequested = true;
        } else if (strcmp(argv[i], "-s") == 0) {
            printSource = true;
        } else {
            // Assume it's the source file
            if (inputFilename == NULL) {
                inputFilename = argv[i];
            } else {
                fprintf(stderr, "Error: Multiple input files specified.\n");
                helpRequested = true; // Show usage for incorrect arguments
                break;
            }
        }
    }

    if (helpRequested) {
        printUsage(argv[0]);
        return 0; // Exit after printing help
    }

    if (inputFilename != NULL) {
        sourceFile = fopen(inputFilename, "r");
        if (!sourceFile) {
            perror("Error opening source file");
            return 1;
        }
    }
    yyin = sourceFile; // Set yyin for Flex

    // Print source code if requested
    if (printSource) {
        printf("Source code from file: %s\n", inputFilename ? inputFilename : "stdin");
        printf("----------------------------------------\n");
        int c;
        while ((c = fgetc(sourceFile)) != EOF) {
            putchar(c);
        }
        printf("----------------------------------------\n");
        rewind(sourceFile); // Go back to the start of the file for the parser
    }

    yydebug = traceParser; // Set Bison debug flag

    if (yyparse() == 0) {
        symbolTable = new SymbolTable(); // Initialize symbol table
        if (traceSymbolTable) {
            symbolTable->debug(true);
        }
        // Perform semantic analysis
        semanticAnalysis(syntaxTree, symbolTable);

        // Now print the tree if requested
        if (printAST) {
            // printTreeRecursive will check the global printWithTypeInfo flag
            printTree(stdout, syntaxTree);
        }
    }

    if (sourceFile != stdin) {
        fclose(sourceFile);
    }

    // Clean up symbol table
    if (symbolTable) {
        delete symbolTable;
        symbolTable = NULL;
    }

    // Print summary
    printf("Number of warnings: %d\n", numWarnings);
    printf("Number of errors: %d\n", numErrors);

    return numErrors > 0 ? 1 : 0; // Return non-zero if errors occurred
}