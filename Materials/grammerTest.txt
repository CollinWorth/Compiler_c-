program         : declList
                ;

declList        : declList decl
                | decl
                ;

decl            : varDecl
                | funDecl
                ;

varDecl         : typeSpec varDeclList ';'
                ;

scopedVarDecl   : STATIC typeSpec varDeclList ';'
                | typeSpec varDeclList ';'
                ;

varDeclList     : varDeclList ',' varDeclInit
                | varDeclInit
                ;

varDeclInit     : varDeclId
                | varDeclId ':' simpleExp
                ;

varDeclId       : ID
                | ID '[' NUMCONST ']'
                ;

typeSpec        : BOOL
                | CHAR
                | INT
                ;

funDecl         : typeSpec ID '(' parms ')' compoundStmt
                | ID '(' parms ')' compoundStmt
                ;

parms           : parmList
                | /* empty */
                ;

parmList        : parmList ';' parmTypeList
                | parmTypeList
                ;

parmTypeList    : typeSpec parmIdList
                ;

parmIdList      : parmIdList ',' parmId
                | parmId
                ;

parmId          : ID
                | ID '[' ']'
                ;

stmt            : expStmt
                | compoundStmt
                | selectStmt
                | iterStmt
                | returnStmt
                | breakStmt
                ;

expStmt         : exp ';'
                | ';'
                ;

compoundStmt    : '{' localDecls stmtList '}'
                ;

localDecls      : localDecls scopedVarDecl
                | /* empty */
                ;

stmtList        : stmtList stmt
                | /* empty */
                ;

selectStmt      : IF simpleExp THEN stmt
                | IF simpleExp THEN stmt ELSE stmt
                ;

iterStmt        : WHILE simpleExp DO stmt
                | FOR ID ASSIGN iterRange DO stmt
                ;

iterRange       : simpleExp TO simpleExp
                | simpleExp TO simpleExp BY simpleExp
                ;

returnStmt      : RETURN ';'
                | RETURN exp ';'
                ;

breakStmt       : BREAK ';'
                ;

exp             : mutable assignop exp
                | mutable INC
                | mutable DEC
                | simpleExp
                ;

assignop        : ASSIGN
                | ADDASS
                | SUBASS
                | MULASS
                | DIVASS
                ;

simpleExp       : simpleExp OR andExp
                | andExp
                ;

andExp          : andExp AND unaryRelExp
                | unaryRelExp
                ;

unaryRelExp     : NOT unaryRelExp
                | relExp
                ;

relExp          : sumExp relop sumExp
                | sumExp
                ;

relop           : LT
                | LE
                | GT
                | GE
                | EQ
                | NEQ
                ;

sumExp          : sumExp sumop mulExp
                | mulExp
                ;

sumop           : '+'
                | '-'
                ;

mulExp          : mulExp mulop unaryExp
                | unaryExp
                ;

mulop           : '*'
                | '/'
                | '%'
                ;

unaryExp        : unaryop unaryExp
                | factor
                ;

unaryop         : '-'
                | '*'
                | '?'
                ;

factor          : mutable
                | immutable
                ;

mutable         : ID
                | ID '[' exp ']'
                ;

immutable       : '(' exp ')'
                | call
                | constant
                ;

call            : ID '(' args ')'
                ;

args            : argList
                | /* empty */
                ;

argList         : argList ',' exp
                | exp
                ;

constant        : NUMCONST
                | CHARCONST
                | STRINGCONST
                | TRUE
                | FALSE
                ;

                %{
/////////////////// Added //////////////////
#include "scanType.h"
#include <stdio.h>
#include <stdlib.h>
int yylex(void);
void yyerror(const char *s);

#define YYERROR_VERBOSE

double vars[26];   

// Declare external variables
extern int yylex();
extern FILE *yyin;
extern int line;
extern int numErrors;

void yyerror(const char *msg)
{
    printf("ERROR(%d): %s\n", line, msg);
    numErrors++;
}

%}

// this is included in the tab.h file
// so scanType.h must be included before the tab.h file!!!!
%union {
    TokenData *tokenData;
    double value;
}


///////////////// top ///////////////
%token <tokenData> ID
%token ID NUMCONST CHARCONST STRINGCONST
%token BOOL CHAR INT STATIC
%token IF THEN ELSE WHILE DO FOR RETURN BREAK
%token TRUE FALSE
%token OR AND NOT
%token ASSIGN ADDASS SUBASS MULASS DIVASS   /* :=, +=, -=, *=, /= */
%token EQ NE LT LE GT GE NEQ                /* relational ops */
%token INC DEC 
%token TO BY

%type <value> expression sumexp mulexp unary factor

%%
//////////////////// Middle ///////////////////////

%%
 ///////////// Bottom //////////////
extern int yydebug;
int main(int argc, char *argv[])
{
    if (argc > 1) {
        if ((yyin = fopen(argv[1], "r"))) {
            // file open successful
        }
        else {
            // failed to open file
            printf("ERROR: failed to open \'%s\'\n", argv[1]);
            exit(1);
        }
    }

    // init variables a through z
    for (int i=0; i<26; i++) vars[i] = 0.0;

    // do the parsing
    numErrors = 0;
    yyparse();

    printf("Number of errors: %d\n", numErrors);   // ERR

    return 0;
}